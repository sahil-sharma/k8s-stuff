global:
  enabled: true
  tlsDisable: false

injector:
  enabled: false

server:
  ha:
    enabled: false
    replicas: 1
    raft:
      enabled: true
      setNodeId: true
      config: |
        ui = true
        listener "tcp" {
          address = "0.0.0.0:8200"
          tls_disable = "true"
          telemetry {
            unauthenticated_metrics_access = "true"
          }
        }
        storage "raft" {
          path    = "/vault/data"
          node_id = "${HOSTNAME}" 
        }
        disable_mlock = true

        telemetry {
          prometheus_retention_time = "30s"
          disable_hostname = true
        }

  ingress:
    enabled: true
    ingressClassName: "nginx"
    pathType: Prefix
    hosts:
      - host: secrets.local.io
        paths:
          - /

  extraEnvironmentVars:
    VAULT_ADDR: http://vault.vault:8200
    VAULT_SKIP_VERIFY: true

  volumeMounts:
  - name: vault-init-volume
    mountPath: /v-data

  extraContainers:
    - name: vault-setup
      image: "hashicorp/vault:1.20.1"
      command: ["/bin/sh", "-c"]
      args:
        - |
          set -e
          echo ""
          echo -e "Sleeping to let Vault start up...\n"
          sleep 10 # Wait for Vault to be ready

          export VAULT_ADDR=http://vault.vault:8200
          export KEY_FILE="/vault/init-keys.txt"
          export K8S_HOST="https://10.0.0.251"
          export K8S_PORT="38217"
          export OIDC_CLIENT_ID="secrets"
          export OIDC_CLIENT_SECRET="SECRET"

          if vault status | grep -q 'Initialized.*false'; then
            echo "Vault not initialized. Starting to initialize Vault..."
            vault operator init -key-shares=1 -key-threshold=1 -format=json > $KEY_FILE
            echo "Vault initialization completed and keys saved to $KEY_FILE"

            echo "Fetching Unseal keys and root token..."
            UNSEAL_KEY=$(cat "$KEY_FILE" | grep '"unseal_keys_hex"' -A 1 | tail -n 1 | sed 's/[", ]//g')
            VAULT_TOKEN=$(cat "$KEY_FILE" | grep root_token | cut -d '"' -f4)           
            
            echo "Unsealing Vault..."
            vault operator unseal "$UNSEAL_KEY"
            
            echo "Logging-in Vault..."
            vault login "$VAULT_TOKEN"

            echo "Enabling KV mounts: apps, database, globals, sso"
            vault secrets enable -path=apps -version=2 kv
            vault secrets enable -path=database -version=2 kv
            vault secrets enable -path=globals -version=2 kv
            vault secrets enable -path=sso -version=2 kv
            vault secrets enable -path=aiml -version=2 kv
            vault secrets enable -path=metrics -version=2 kv

            echo "Storing the init JSON in the internal KV store for safekeeping..."
            vault kv put sso/vault/init root_token="$VAULT_TOKEN" keys_file="$(cat "$KEY_FILE")"

            echo "Creating example secrets"
            vault kv put apps/welcome-app APP_USERNAME="usera" APP_PASSWORD="passa"
            vault kv put database/postgres db_username="pguser" db_password="pgpass"
            vault kv put globals/common api_key="globalapikey123"
            vault kv put aiml/models llm_api_key="apikey123"

            echo "Writing policies (admin, reader, app, eso-read, data-reader, read-metrics)"
            printf '%s\n' \
            'path "*" { capabilities = ["create","read","update","delete","list","sudo"] }' \
            > /tmp/admin.hcl
            vault policy write admin /tmp/admin.hcl

            printf '%s\n' \
            'path "apps/data/*" { capabilities = ["read","list"] }' \
            'path "apps/metadata/*" { capabilities = ["list"] }' \
            'path "globals/data/*" { capabilities = ["read","list"] }' \
            'path "globals/metadata/*" { capabilities = ["list"] }' \
            > /tmp/reader.hcl
            vault policy write reader /tmp/reader.hcl

            printf '%s\n' \
            'path "apps/data/*" { capabilities = ["read","list"] }' \
            'path "apps/metadata/*" { capabilities = ["list"] }' \
            'path "database/data/*" { capabilities = ["read","list"] }' \
            'path "database/metadata/*" { capabilities = ["list"] }' \
            'path "globals/data/*" { capabilities = ["read","list"] }' \
            'path "globals/metadata/*" { capabilities = ["list"] }' \
            'path "/aiml/data/*" { capabilities = ["read","list"] }' \
            'path "/aiml/metadata/*" { capabilities = ["list"] }' \
            > /tmp/app.hcl
            vault policy write app /tmp/app.hcl

            printf '%s\n' \
            'path "data/data/*" { capabilities = ["read","list"] }' \
            'path "data/metadata/*" { capabilities = ["list"] }' \
            > /tmp/data-reader.hcl
            vault policy write data-reader /tmp/data-reader.hcl

            echo "Creating Policy for External-Secrets Operator"
            cp /tmp/app.hcl /tmp/eso-read.hcl
            vault policy write eso-read /tmp/eso-read.hcl
            
            echo "Creating Policy for Prometheus to scrape metrics"
            printf '%s\n' \
            'path "/sys/metrics" { capabilities = ["read"] }' \
            > /tmp/read-metrics.hcl
            vault policy write read-metrics /tmp/read-metrics.hcl

            echo "Creating token for Prometheus to scrape metrics"
            vault token create -field=token -policy read-metrics  > /tmp/metrics-token.txt

            echo "Saving metrics token to Internal KV store /metrics/token path" 
            vault kv put metrics/token token="$(cat /tmp/metrics-token.txt)"

            printf '%s\n' \
            'path "auth/token/lookup-self" { capabilities = ["read"] }' \
            'path "auth/token/renew-self" { capabilities = ["update"] }' \
            'path "auth/token/revoke-self" { capabilities = ["update"] }' \
            'path "sys/capabilities-self" { capabilities = ["update"] }' \
            > /tmp/default.hcl
            vault policy write default-role /tmp/default.hcl

            printf '%s\n' \
            'path "sys/metrics" { capabilities = ["read"] }' \
            > /tmp/read-metrics.hcl
            vault policy write read-metrics /tmp/read-metrics.hcl

            echo "Enabling OIDC auth method..."
            vault auth enable -path=oidc oidc

            vault write auth/oidc/config \
              oidc_discovery_url="http://sso.local.io:32080/realms/platform" \
              oidc_client_id="$OIDC_CLIENT_ID" \
              oidc_client_secret="$OIDC_CLIENT_SECRET" \
              default_role="reader"

            vault write auth/oidc/role/admin \
              bound_audiences="secrets" \
              user_claim="preferred_username" \
              groups_claim="groups" \
              allowed_redirect_uris="http://secrets.local.io:32080/ui/vault/auth/oidc/oidc/callback" \
              allowed_redirect_uris="http://secrets.local.io:32080/oidc/callback" \
              allowed_redirect_uris="http://vault.vault:8250/oidc/callback" \
              policies="admin" \
              ttl="1h" \
              bound_claims.groups='["devops"]'

            vault write auth/oidc/role/reader \
              bound_audiences="secrets" \
              user_claim="preferred_username" \
              groups_claim="groups" \
              allowed_redirect_uris="http://secrets.local.io:32080/ui/vault/auth/oidc/oidc/callback" \
              allowed_redirect_uris="http://secrets.local.io:32080/oidc/callback" \
              allowed_redirect_uris="http://vault.vault:8250/oidc/callback" \
              policies="reader" \
              ttl="1h" \
              bound_claims.groups='["engineering"]'

            vault write auth/oidc/role/data-reader \
              bound_audiences="secrets" \
              user_claim="preferred_username" \
              groups_claim="groups" \
              allowed_redirect_uris="http://secrets.local.io:32080/ui/vault/auth/oidc/oidc/callback" \
              allowed_redirect_uris="http://secrets.local.io:32080/oidc/callback" \
              allowed_redirect_uris="http://vault.vault:8250/oidc/callback" \
              policies="data-reader" \
              ttl="1h" \
              bound_claims.groups='["data"]'

            vault write auth/oidc/role/default \
              bound_audiences="secrets" \
              user_claim="preferred_username" \
              groups_claim="groups" \
              allowed_redirect_uris="http://secrets.local.io:32080/ui/vault/auth/oidc/oidc/callback" \
              allowed_redirect_uris="http://secrets.local.io:32080/oidc/callback" \
              allowed_redirect_uris="http://vault.vault:8250/oidc/callback" \
              policies="default" \
              ttl="1h" \
              bound_claims.groups='["*"]'

            # Enable only OIDC in the UI
            vault auth tune -listing-visibility=unauth oidc

            echo "Enabling Kubernetes auth method..."
            vault auth enable kubernetes

            vault write auth/kubernetes/config \
              kubernetes_host="$K8S_HOST":"$K8S_PORT" \
              issuer="https://kubernetes.default.svc.cluster.local"

            vault write auth/kubernetes/role/welcome-app-role \
              bound_service_account_names="welcome-app-service-account" \
              bound_service_account_namespaces="welcome-app" \
              policies="eso-read" \
              audience="https://kubernetes.default.svc.cluster.local" \
              ttl="1h"

            vault write auth/kubernetes/role/read-metrics-role \
              bound_service_account_names="prometheus-server" \
              bound_service_account_namespaces="prometheus" \
              policies="read-metrics" \
              audience="https://kubernetes.default.svc.cluster.local"

            echo "Initscript executed successfully, idling..."
          else
            echo "Vault is already initialized. Skipping initialization."
          fi

          # Keep container running
          tail -f /dev/null

      volumeMounts:
        - name: vault-init-volume
          mountPath: /vault

  volumes:
    - name: vault-init-volume
      emptyDir: {}
